/*
* displayReceiver.c
*
* Created: 20/11/2012 15:17:11
*  Author: dsanchez
*/

#define F_CPU 1000000UL  // 1 MHz

#include <avr/io.h>
#include <avr/pgmspace.h>
#include <string.h>
#include <util/delay.h>

#define A0 PA0 // es la salida PA0, high=display data, low=control data
#define lcdRST PA1// es la salida PA1

#define spiInited 0x01

char flags;
static uint8_t column;
static uint8_t cursorx;
static uint8_t cursory;

const unsigned char font[] PROGMEM = {

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // ' '
	0x00, 0x00, 0x00, 0x00, 0x0B, 0xF8, 0x00, 0x00, 0x00, 0x00,    // '!'
	0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,    // '"'
	0x02, 0x20, 0x0F, 0xF8, 0x02, 0x20, 0x0F, 0xF8, 0x02, 0x20,    // '#'
	0x04, 0x60, 0x08, 0x90, 0x1F, 0xF8, 0x09, 0x10, 0x06, 0x20,    // '$'
	0x06, 0x10, 0x01, 0x28, 0x04, 0x90, 0x0A, 0x40, 0x04, 0x30,    // '%'
	0x07, 0x30, 0x08, 0xC8, 0x09, 0x30, 0x06, 0x00, 0x09, 0x00,    // '&'
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00,    // '''
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x10, 0x04, 0x00, 0x00,    // '('
	0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x0F, 0xF8, 0x00, 0x00,    // ')'
	0x01, 0x10, 0x00, 0xA0, 0x03, 0xF8, 0x00, 0xA0, 0x01, 0x10,    // '*'
	0x01, 0x00, 0x01, 0x00, 0x07, 0xC0, 0x01, 0x00, 0x01, 0x00,    // '+'
	0x00, 0x00, 0x2C, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00,    // ','
	0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,    // '-'
	0x0C, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // '.'
	0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x38, 0x00, 0x00,    // '/'
	0x07, 0xF0, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0xF0,    // '0'
	0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xF8, 0x00, 0x00,    // '1'
	0x0C, 0x10, 0x0A, 0x08, 0x09, 0x08, 0x08, 0x88, 0x08, 0x70,    // '2'
	0x04, 0x10, 0x08, 0x08, 0x08, 0x88, 0x08, 0x88, 0x07, 0x70,    // '3'
	0x03, 0x00, 0x02, 0xC0, 0x02, 0x30, 0x0F, 0xF8, 0x02, 0x00,    // '4'
	0x04, 0xF8, 0x08, 0x48, 0x08, 0x48, 0x08, 0x48, 0x07, 0x88,    // '5'
	0x07, 0xF0, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x07, 0x10,    // '6'
	0x00, 0x08, 0x0E, 0x08, 0x01, 0x88, 0x00, 0x68, 0x00, 0x18,    // '7'
	0x07, 0x70, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x07, 0x70,    // '8'
	0x04, 0x70, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x07, 0xF0,    // '9'
	0x0C, 0xC0, 0x0C, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // ':'
	0x00, 0x00, 0x2C, 0xC0, 0x1C, 0xC0, 0x00, 0x00, 0x00, 0x00,    // ';'
	0x01, 0x00, 0x02, 0x80, 0x04, 0x40, 0x08, 0x20, 0x00, 0x00,    // '<'
	0x02, 0x80, 0x02, 0x80, 0x02, 0x80, 0x02, 0x80, 0x02, 0x80,    // '='
	0x08, 0x20, 0x04, 0x40, 0x02, 0x80, 0x01, 0x00, 0x00, 0x00,    // '>'
	0x00, 0x10, 0x00, 0x08, 0x0B, 0x08, 0x00, 0x88, 0x00, 0x70,    // '?'
	0x01, 0xE0, 0x02, 0x10, 0x04, 0xC8, 0x05, 0x28, 0x02, 0xF0,    // '@'
	0x0F, 0x00, 0x02, 0xE0, 0x02, 0x18, 0x02, 0xE0, 0x0F, 0x00,    // 'A'
	0x0F, 0xF8, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x07, 0x70,    // 'B'
	0x07, 0xF0, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x04, 0x10,    // 'C'
	0x0F, 0xF8, 0x08, 0x08, 0x08, 0x08, 0x04, 0x10, 0x03, 0xE0,    // 'D'
	0x0F, 0xF8, 0x08, 0x88, 0x08, 0x88, 0x08, 0x08, 0x00, 0x00,    // 'E'
	0x0F, 0xF8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x08, 0x00, 0x00,    // 'F'
	0x07, 0xF0, 0x08, 0x08, 0x08, 0x88, 0x04, 0x88, 0x0F, 0x90,    // 'G'
	0x0F, 0xF8, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x0F, 0xF8,    // 'H'
	0x00, 0x00, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // 'I'
	0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07, 0xF8, 0x00, 0x00,    // 'J'
	0x0F, 0xF8, 0x00, 0xC0, 0x01, 0x20, 0x02, 0x10, 0x0C, 0x08,    // 'K'
	0x0F, 0xF8, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00,    // 'L'
	0x0F, 0xF8, 0x00, 0x70, 0x01, 0x80, 0x00, 0x70, 0x0F, 0xF8,    // 'M'
	0x0F, 0xF8, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x0F, 0xF8,    // 'N'
	0x07, 0xF0, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0xF0,    // 'O'
	0x0F, 0xF8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0x70,    // 'P'
	0x07, 0xF0, 0x08, 0x08, 0x0A, 0x08, 0x0C, 0x08, 0x17, 0xF0,    // 'Q'
	0x0F, 0xF8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x0F, 0x70,    // 'R'
	0x04, 0x70, 0x08, 0x88, 0x08, 0x88, 0x08, 0x88, 0x07, 0x10,    // 'S'
	0x00, 0x08, 0x00, 0x08, 0x0F, 0xF8, 0x00, 0x08, 0x00, 0x08,    // 'T'
	0x07, 0xF8, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07, 0xF8,    // 'U'
	0x00, 0x38, 0x03, 0xC0, 0x0C, 0x00, 0x03, 0xC0, 0x00, 0x38,    // 'V'
	0x00, 0xF8, 0x0F, 0x00, 0x00, 0xE0, 0x0F, 0x00, 0x00, 0xF8,    // 'W'
	0x0E, 0x38, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x0E, 0x38,    // 'X'
	0x00, 0x38, 0x00, 0x40, 0x0F, 0x80, 0x00, 0x40, 0x00, 0x38,    // 'Y'
	0x0C, 0x08, 0x0B, 0x08, 0x08, 0x88, 0x08, 0x68, 0x08, 0x18,    // 'Z'
	0x00, 0x00, 0x1F, 0xFC, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00,    // '['
	0x00, 0x00, 0x00, 0x38, 0x00, 0xC0, 0x03, 0x00, 0x0C, 0x00,    // '\'
	0x00, 0x00, 0x10, 0x04, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00,    // ']'
	0x00, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10,    // '^'
	0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00,    // '_'
	0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    // '`'
	0x06, 0x00, 0x09, 0x40, 0x09, 0x40, 0x09, 0x40, 0x0F, 0x80,    // 'a'
	0x0F, 0xF8, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x07, 0x80,    // 'b'
	0x07, 0x80, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x04, 0x80,    // 'c'
	0x07, 0x80, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x0F, 0xF8,    // 'd'
	0x07, 0x80, 0x09, 0x40, 0x09, 0x40, 0x09, 0x40, 0x05, 0x80,    // 'e'
	0x0F, 0xF0, 0x00, 0x48, 0x00, 0x48, 0x00, 0x48, 0x00, 0x10,    // 'f'
	0x27, 0x80, 0x28, 0x40, 0x28, 0x40, 0x28, 0x40, 0x1F, 0xC0,    // 'g'
	0x0F, 0xF8, 0x00, 0x80, 0x00, 0x40, 0x00, 0x40, 0x0F, 0x80,    // 'h'
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xC8, 0x00, 0x00, 0x00, 0x00,    // 'i'
	0x20, 0x00, 0x20, 0x00, 0x1F, 0xC8, 0x00, 0x00, 0x00, 0x00,    // 'j'
	0x0F, 0xF8, 0x01, 0x00, 0x02, 0x80, 0x04, 0x40, 0x08, 0x00,    // 'k'
	0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x00,    // 'l'
	0x0F, 0xC0, 0x00, 0x40, 0x0F, 0x80, 0x00, 0x40, 0x0F, 0x80,    // 'm'
	0x0F, 0xC0, 0x00, 0x80, 0x00, 0x40, 0x00, 0x40, 0x0F, 0x80,    // 'n'
	0x07, 0x80, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x07, 0x80,    // 'o'
	0x3F, 0xC0, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x07, 0x80,    // 'p'
	0x07, 0x80, 0x08, 0x40, 0x08, 0x40, 0x08, 0x40, 0x3F, 0xC0,    // 'q'
	0x0F, 0xC0, 0x00, 0x80, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00,    // 'r'
	0x04, 0x80, 0x09, 0x40, 0x0A, 0x40, 0x04, 0x80, 0x00, 0x00,    // 's'
	0x07, 0xF0, 0x08, 0x40, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00,    // 't'
	0x07, 0xC0, 0x08, 0x00, 0x08, 0x00, 0x04, 0x00, 0x0F, 0xC0,    // 'u'
	0x00, 0xC0, 0x03, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0,    // 'v'
	0x01, 0xC0, 0x0E, 0x00, 0x01, 0xC0, 0x0E, 0x00, 0x01, 0xC0,    // 'w'
	0x0C, 0xC0, 0x03, 0x00, 0x03, 0x00, 0x0C, 0xC0, 0x00, 0x00,    // 'x'
	0x20, 0x00, 0x23, 0xC0, 0x1C, 0x00, 0x04, 0x00, 0x03, 0xC0,    // 'y'
	0x0C, 0x40, 0x0A, 0x40, 0x09, 0x40, 0x08, 0xC0, 0x00, 0x00,    // 'z'
	0x00, 0x00, 0x00, 0x80, 0x0F, 0x78, 0x10, 0x04, 0x00, 0x00,    // '{'
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00,    // '|'
	0x00, 0x00, 0x10, 0x04, 0x0F, 0x78, 0x00, 0x80, 0x00, 0x00,    // '}'
	0x00, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10,    // '~'
	0x00, 0x38, 0x00, 0x44, 0x00, 0x44, 0x00, 0x44, 0x00, 0x38,    // ''
};

void spiInit(void){
	
	// ponermos el SPI en modo master, hay que tener en cuenta que hay que gestionar
	// el A0 y el RESET del display "a mano"
	
	SPDR = (1<<DDB5)|(1<<DDB7); // ¿?¿?¿?
	
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<CPOL);
	
	// A0 y RESET
	
	DDRA = (1<<A0)|(1<<lcdRST);
	
}

char spiTransmit(char cData) {

	SPDR = cData;

	while(!(SPSR&(1<<SPIF)));

	return cData;

}


void lcdControl(unsigned char control){
	// Write a control value to the ST7565
	
	// secure that PA0 and PA1 are configured as output
		
	DDRA = (1<<A0)|(1<<lcdRST);
	
	// put RST to high y A0 to low to indicate control data
	
	PORTA = (PORTA|(1<<lcdRST))|(PORTA&(1<<A0));
	
	// to initialize SPI peripheral
	
	if(!(flags&spiInited)){	
		spiInit();
	}
	
	// data to transmit
	
	spiTransmit(control);
	
	// SPI automatically puts CS high
	// there is no need to put lcdRST down
	
	// it's possible there is no need to change A0
	
	_delay_ms(100);
	
}

void lcdWrite(char data){
	// writes to the currently selected column of the display
	
	// put RST to high y A0 to high to indicate display data
	
	PORTA = (PORTA|(1<<lcdRST))|(PORTA|(1<<A0));
	
	if(!(flags&spiInited)){
		spiInit();
	}
	
	spiTransmit(data);
	
	// SPI automatically puts CS high
	// there is no need to put lcdRST down
	
	// it's possible there is no need to change A0
	
}

void lcdSetColumn(unsigned char cx, unsigned char cy){
	
	// set the controller chip data to match the required column and row

	// as all the code expects 120 pixels, and we have 128

	// we will offset four to the right to centralize stuff

	// and give a bit of a border to improve legibility

	column = cx;

	// the column must be set in two writes, with four bits each

	// lsb

	lcdControl((cx+4) & 0x0f);                           // <-0000 3210

	// msb
	
	lcdControl((((cx+4) & 0xf0) >> 4) | 0x10);   // <-0001 7654

	// only a single write for the row

	// there's actually a ninth row of one bit which we don't use

	lcdControl((cy & 7) | 0xb0);                  // <-1011 3210

	return;
	
}

void lcdCls(void){
	int r, q;

	for (r=0; r<8; r++)
	{
		lcdSetColumn(-4,r);      // set_column adds 4 to the position
		for (q=0; q<128; q++)
		{
			lcdWrite(0);
		}
	}
}
	
void lcdInit(void){ // TODO:: esta función está mal implementada
	
	// reset the display and clear it
	// hardware reset, 100 ms
	
	// not clear it's need to manipulate SPI ports
	// rest of the control lines HIGH except RESET
	
	//PORTA = (PORTA&(0<<lcdRST))|(PORTA&(1<<A0)); //TODO:: comprobar lo del cero
	
	PORTA = (PORTA&0x00)|(PORTA|0x01);
	
	// delay de 100 ms
	
	_delay_ms(100);
	
 	// put RST high
	 
	PORTA |= (1<<lcdRST);

	lcdControl(0xA2);      // <- Bias 1/9

	lcdControl(0xA0);      // <- ADC Direction L-R

	lcdControl(0xC0);      // <- SHL Direction 0-64

	lcdControl(0x25);      // <- Voltage ref

	lcdControl(0x81);      // <- Volume mode

	lcdControl(0x18);      // <- Volume set

	//lcd_control(0xF8);      // <- Booster ratio = 4

	lcdControl(0x00);      // <- ??

	lcdControl(0x2F);      // <- Vf, Vr, Vc on

	lcdControl(0x40);      // <- Initial display line

	lcdControl(0xA7);      // <- Normal display

	lcdControl(0xAF);      // <- turn display on

	lcdControl(0xB0);      // <- page address = 0

	lcdControl(0x10);      // <- column address high = 0

	lcdControl(0x00);      // <- column address low = 0
	
	lcdCls();
	
	return;
	
}


void lcdSetCursor(unsigned char cx, unsigned char cy){
	
	// put the cursor on a specified cell, and set the column value at the same time
	// we have eight rows to play with, 128 columns but we use double-height characters
	// so we have four by twenty rows of characters

	cursorx = cx;
	cursory = cy;

	lcdSetColumn(cx*6, cy*2);
	
}

void lcdChar(char cData){

	uint16_t ptr;
	int q;

	// write ch to the screen at the current cursor position
	// update the cursor position and scroll to the next line
	// if required
	// to avoid scrolling the screen if we need to use 19,3 the
	// cursor is moved to the top of the screen again
	// when we arrive, the cursor is already set
	//
	// note that although we have eight lines on the display we
	// only have four lines of text - 0-3. set_cursor sorts out the conversion
	//
	// Our font is sixteen deep (with some leading) and six wide including the
	// separating space

	// we set the cursor to where we already are, which sets up the column

	lcdSetCursor(cursorx, cursory); // TODO:: what the hell is cursorx and cursory

	// now we work out where in the font array the character lives, get the ten bytes
	// that define the character, and stuff them to the display, followed by a zero for space
	// the characters start with 0x20

	ptr = (uint16_t)(((cData - 0x20)*10)+1); // point to low byte of font data

	for (q = 0; q < 5; q++)
	{
		// first the top row
		//lcd_write(0xff);
		lcdWrite(pgm_read_byte(&font[ptr]));
		ptr+=2;
	}

	lcdWrite(0);  // the space between the words

	ptr = (uint16_t)(((cData - 0x20)*10)); // point to high byte of font data

	//ptr -=9;  // point back to the start of the char

	lcdSetColumn(cursorx*6, (cursory*2)+1);

	for (q = 0; q < 5; q++)
	{
		// the bottom row
		//lcd_write(0xff);

		lcdWrite(pgm_read_byte(&font[ptr]));
		ptr+=2;
	}

	lcdWrite(0);
	// increment the cursor to the next place
	cursorx++;

	if (cursorx == 20)
	{
		cursorx = 0;
		cursory++;
	}

	if (cursory > 3)
	cursory = 0;
}

void lcdPrint(char * cData){
	
	int q;

	// print a string to the lcd

	for (q=0; q<strlen(cData); q++)
	{

		lcdChar(cData[q]);

	}
	
}


int main(void)
{
	
	char nothing = 120;
			
	spiInit();
	flags |= 0x01;
	
	lcdInit();
	
	lcdControl(0b10100111);
			
	lcdPrint("bla");
	
    while(1)
    {
        //TODO:: Write the main application 

    }
}